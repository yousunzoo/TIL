# IP에 대해 알아보자

## 패킷(packet)

IP(Internet Protocol)은 인터넷에서 데이터(정확히는 패킷)를 주고받을 때 사용하는 통신 규약이다.

패킷은 소포를 의미하는 단어로, 데이터를 작은 조각으로 쪼갠 것을 의미한다.

데이터를 패킷으로 쪼개는 이유는, 무거운 데이터를 그대로 보내면 가는 도중 회선에 문제가 생겼을 때 다시 전송하기 위해 많은 자원을 낭비할 수 있기 때문이다. 예를 들어 과자 한 박스를 택배로 보낸다면 과자에 이상이 있거나 잘못된 장소에 도착했을 때 다시 한 박스를 만들어 보내야 하는데, 같은 양을 각 한 봉지씩 보내면 그중 한 봉지에 문제가 생겼을 때 그만큼의 과자만 새로 보내면 되는 것과 같은 원리이다.

이렇게 패킷을 이용해 정보를 교환하는 방식을 패킷 교환 방식이라고 부른다.

패킷 교환 방식의 또 다른 특징은 패킷 별로 최적의 경로를 선택해 이동한다는 것이다.

데이터는 목적지에 도달하기 위해 많은 중간 경로를 거치는데, 이때 데이터를 패킷으로 나누어 전달하게 되면 패킷이 자신에게 주어진 모든 경로 중 혼잡도, 연결 상태 등을 파악해 최적의 경로를 찾아가기 때문에 다양한 회선을 효율적으로 이용할 수 있고, 특정 경로에 문제가 생겨도 다른 경로로 이동하는 패킷은 안정적으로 들어올 수 있다는 장점이 있다.

참고로 IP에서 다루는 패킷의 최대 크기는 약 65KB이다.

## IP의 특징

IP의 주된 역할은 패킷을 정해진 목적지까지 전달하는 일이다. 외부에서 패킷이 들어오면 내 IP 주소와 맞는지 비교하고, 일치하지 않으면 다른 호스트로 전달한다. 주의할 점은 IP는 패킷의 전달을 책임지는 프로토콜이며 패킷의 손실이나 중복과 같은 상태 이상을 확인하지 않는다는 것이다. 때문에 비신뢰성(unreliable)과 비연결성(connectionless)이라는 특징을 가진다.

### IPv4

우리가 자주 보는 IP 주소는 192.168.0.1처럼 긴 숫자 사이에 점이 들어간 형태이다. 그런데 사실 IP의 버전에 따라 이 주소 구조가 다르다.

IP는 탄생 직후부터 지금까지 다양한 버전이 만들어졌는데, 그중 우리가 자주 접하는 주소 체계는 IPv4(Internet Protocol version 4)이다.

![IPv4](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb9dNau%2Fbtsp1i9fX2I%2FGPVjNRm2WRRPd5NnMxoQq1%2Fimg.png)

IPv4 주소는 점을 기준으로 4부분으로 나눌 수 있고, 각 자리는 0부터 255까지의 숫자로 구성된다. 보통 이렇게 10진수로 표현하는데, 사실 원래 IP 주소는 2진수이다. 다만 2진수로는 웹 사이트 주소를 찾기 불편하므로 사용자에게 편한 10진수로 바뀐 것이다.

2진수로 표현했을 때 점을 기준으로 비트가 8개씩 나뉘는데, 이렇게 8비트씩 묶은 것을 옥텟이라 부르고, 각 옥텟은 00000000부터 11111111까지 표현할 수 있다. 이를 10진수로 변환하면 0부터 255이다. 따라서 IP 주소의 어떤 값이 256이라면 그건 유효하지 않은 IP 주소이다.

## 네트워크 주소와 호스트 주소

IP 주소는 보기에는 한 덩어리로 보일 수 있지만 네트워크 부분과 호스트 부분으로 나눌 수 있다.

보통 인터넷에서 데이터를 받을 때 요청한 컴퓨터로 직접 데이터가 들어오지 않고 먼저 해당 컴퓨터가 연결된 공유기에 전달된다. 그럼 공유기는 자신에게 연결된 컴퓨터 중에서 데이터를 요청한 컴퓨터가 있는지 확인하고, 있다면 그 컴퓨터에 다시 데이터를 전달한다.

IP 주소에서 사용하는 네트워크는 데이터를 통신하는 과정에서 같은 공유기를 사용하는 범위를 말하며, 이 네트워크에 연결된 각각의 장치를 호스트라고 부른다.

IP 주소는 데이터가 들어올 때 가장 먼저 해당 컴퓨터가 속한 네트워크에 진입해야 하므로 이를 찾기 위한 구분자로 IP 주소의 맨 앞에 네트워크 부분을 표기하고, 그 안에서 다시 특정 호스트를 찾기 위한 구분자로 네트워크 부분의 뒤에 호스트 부분을 작성한다.

예를 들어, 경기 수원시 화서동 AA빌라 $$호라는 주소에서 경기 수원시 화서동 AA빌라같은 기본 주소는 네트워크 부분, $$호와 같은 상세 주소는 호스트 부분이 된다.

192.168.123.132라는 IP 주소에서 192.168.123까지가 네트워크 부분이라면 이를 제외한 나머지 .132는 호스트 부분으로 볼 수 있다.

이때 주의할 점은 하나의 네트워크에서 사용할 수 있는 IP 주소 중 맨 첫 번째 주소인 0과 맨 마지막 주소인 255는 호스트 주소로 사용할 수 없다는 점이다. 그 이유는 사회적으로 0은 네트워크 그 자체의 주소, 255는 브로트캐스트를 위한 주소이기 때문이다.

네트워크 주소를 작성하기 위해서는 호스트 부분을 제거함으로써 비어있는 부분을 0으로 채운다. 따라서 192.168.123.0이라는 주소는 192.168.123의 네트워크 자체 주소가 되며, 따로 호스트 주소로 쓸 수 없게 된다.

브로드캐스트 주소는 간단하게 설명하자면 특정 네트워크 주소에 속한 모든 호스트에게 패킷을 전달해야 할 때 사용하는 주소이다. 브로드캐스트는 IP 통신에 있어 중요한 역할을 하므로 네트워크 내에서 맨 마지막 IP 주소는 브로드캐스트 주소로 사용하기로 약속되어 있다.

이러한 이유로 192.168.123이라는 네트워크에서 사용할 수 있는 IP 주소는 192.168.123.1부터 192.168.123.254까지로 볼 수 있다.

## 클래스

사실 네트워크 부분과 호스트 부분은 고정되어 있지 않다. IPv4에서 만들 수 있는 IP 주소 개수가 한정적이다 보니 아껴서 사용해야 하는데, IP 주소당 호스트 주소의 개수를 고정하게 되면 호스트가 많은 조직의 경우 한 개의 IP 주소만으로 충분하지 않으니 여러 개의 IP 주소를 사용하고, 반대로 가정집과 같이 호스트가 적은 경우에는 사용하지 않아 낭비되는 호스트 주소가 생기게 된다.

이렇게 네트워크 부분과 호스트 부분을 고정했을 때의 문제점을 해결하기 위해 IP주소에서 네트워크 부분과 호스트 부분을 유동적으로 조절하고자 클래스(class)라는 개념이 나오게 되었다.

클래스는 하나의 IP 주소에서 네트워크 부분과 호스트 부분을 나누는 방법이자 약속이다. 하나의 네트워크에 몇 개의 호스트 주소를 가져갈 수 있는지에 따라 클래스를 나눈다.

클래스의 종류는 A, B, C, D, E로 총 5개가 있으며, D, E는 특수용이기 때문에 A, B, C 클래스를 위주로 다루고자 한다.

- A 클래스 : 첫 번째 옥텟만 네트워크 영역을 나타내고 나머지 부분은 호스트 영역을 나타낸다. 따라서 하나의 네트워크가 가질 수 있는호스트 수가 약 1,600만 개로 세 클래스 중 가장 많다.
- B 클래스 : 두 번째 옥텟까지 네트워크 영역을 나타내며 약 6만 5천개의 호스트 주소를 가질 수 있다.
- C 클래스 : 세 번째 옥텟까지 네트워크 영역을 나타내며 A, B 클래스에 비해 상대적으로 적은 약 250개의 호스트 주소를 가질 수 있다.

클래스 별로 네트워크를 구분하는 방식은 오래가지 못했다. 클래스의 종류가 실질적으로 3개만 있다보니 클래스 별로 할당할 수 있는 호스트의 개수 차이가 크기 때문이다. 대부분의 사이트가 클래스 C에 들어가기에는 크다 보니 B 클래스를 많이 할당받았고, 그에 따라 약 16,000개 밖에 없던 B 클래스가 급속도로 소진되었다. 따라서 오늘날에는 클래스 기반으로 네트워크를 구분하지 않고 CIDR 등 새로운 구분 방식으로 네트워크를 구분한다.

## CIDR와 서브넷 마스크

### CIDR(Classless Inter-Domain Routing, 사이더)

CIDR는 클래스 없는 도메인 간 라우팅 기번으로, 쉽게 말해 클래스 없이도 IP 주소를 할당할 수 있는 새로운 방식이다.

CIDR은 네트워크 부분과 호스트 부분의 구분점을 2진수의 한 자릿수, 즉 1비트 단위까지 가능하게 해 호스트 주소를 더 유연하게 할당할 수 있게 했다. 이렇게 CIDR를 도입한 뒤 기존 클래스 할당 방식보다 더 잘게 IP 주소를 쪼개 사용함으로써 사용자들은 필요한 호스트 개수만큼 사용할 수 있게 되었고 부족한 IP 주소도 더 효율적으로 활욜할 수 있게 되었다.

### 서브넷 마스크(Subnet mask)

서브넷 마스크는 네트워크와 호스트 부분을 구분해주는 역할로, IPv4 주소와 같에 32비트로 표현한다.

IP 주소와 서브넷 마스크를 2진수로 바꾸고 나란히 놓았을 때 서브넷 마스크의 1이 연속한 자릿수를 IP 주소의 네트워크 부분, 나머지 0이 있는 자릿수를 호스트 부분으로 구분할 수 있다.

![서브넷 마스크](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FSkk9X%2Fbtsp2j7O66d%2FJ1xt6m0q37sCWFpRAwzKNk%2Fimg.jpg)
이때 중요한 것은 서브넷 마스크의 1은 연속적으로 배치되어야 한다는 점이다. 11110011과 같은 식으로 1과 0이 섞여 있으면 어디까지가 네트워크 부분인지 정확히 할 수 없기 때문이다.

### CIDR 표기법

서브넷 마스크의 매번 긴 숫자를 일일이 입력하거나 확인하지 않고, 단순히 연속된 1의 개수가 몇 개인지만 알면 네트워크 부분을 더 쉽게 파악할 수 있다.

이런 맥락에서 CIDR는 IP 주소와 서브넷 마크스를 함께 적는 표기법을 사용하고 있다.
![CIDR](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbkumZc%2FbtspTLLwRXQ%2F2MGepfC1k9xsJacvtybJyk%2Fimg.png)

이렇게 CIDR 표기법을 이용하면 IP 주소와 서브넷 마스크를 한눈에 파악할 수 있다는 장점이 있다.

## DHCP

일반적으로 우리가 일상에서 사용하는 IP 주소는 대부분 ISP에서 제공하는 유동 IP이다. 고정 IP는 서버를 운영해야 하는 등 특수한 상황일 때 주로 사용하며, 사용하는 통신사의 ISP에 별도로 신청해 고정 IP를 할당받을 수 있다.

DHCP(Dynamic Host Configuration Protocol)는 IP가 필요한 컴퓨터에 자동으로 IP 주소를 할당해서 사용하게 해주고, 사용하지 않으면 IP 주소를 반환받아 다른 컴퓨터가 사용할 수 있게 해주는 프로토콜이다. 이런 DHCP는 IP 주소를 관리하는 기기에 자동으로 추가되어 있다.

IP 주소에 대한 요청이 들어오면 DCHP 서버는 현재 할당할 수 있는 IP 주소를 찾고, 해당 IP 주소를 일정 기간동안 빌려준다. (중간 갱신 요청 가능) 임대 기간이 끝났거나 IP 주소를 더 이상 사용하지 않으면 컴퓨터는 DHCP 서버에 IP 주소를 반환한다.

## 사설 IP와 NAT

원래라면 모든 컴퓨터마다 IP 주소를 하나씩 가져가야 하는데, 그렇게 되면 IP 주소가 금방 소진될 위험이 있다. 따라서 특정 네트워크 별로 고유한 IP 주소는 한 개씩만 가져가되, 그 네트워크 안에 있는 호스트들은 따로 가상 IP 주소를 할당해 서로 구분할 수 있게 되었다.

이때 인터넷 상에서 유일한 주소이자 ISP에서 공식적으로 할당하는 주소를 공인 IP, 상세 주소에 해당하며 특정 네트워크 내에서 사적인 용도로 이용하는 주소를 사설 IP라고 부른다. (보통 192.168로 시작)

NAT(Network Address Translation)은 네트워크 주소를 변환하는 기술로, 공유기에 자동으로 탑재되어 있다. 공인 IP에서 사설 IP, 사설 IP에서 공인 IP로 변환하는 등 NAT를 통해 IP를 다양한 방법으로 전환할 수 있다.

NAT를 통해 꼭 필요한 곳에서만 공인 IP를 사용하고, 그렇지 않으면 사설 IP를 사용할 수 있게 되면서 꼭 필요한 곳에만 효율적으로 IP를 할당할 수 있게 되었고 IP 고갈을 더 늦출 수 있게 되었다.

### IPv6

IPv6(Internet Protocol version 6)는 기존 IP 체계인 IPv4 고갈 사태를 해결하기 위한 대안으로 만들어졌다.

IPv6 주소는 IPv4의 4배인 128비트까지 늘어났다. 실제 할당할 수 있는 IP 주소 개수는 2의 128승으로 거의 무한대이다.

IPv6는 16진수를 사용한다. 16진수의 경우 0부터 9까지는 그대로 사용하고 그 이상은 차례로 a(10), b(11), c(12), d(13), e(14), f(15)를 사용하고, 2 옥텟 단위마다 콜론(:)으로 구분한다.
