# 선주

# 리액트 패키지 구조

// 16 ver 기준

- **React** : 컴포넌트 정의와 관련된 패키지. createElement()와 개발자에게 다른 패키지의 모듈을 제공하는 중간 다리 역할. 다른 패키지에 의존 X, 여러 플랫폼에 올려서 사용 가능
- **renderer** : react-dom, react-native-renderer 등 호스트 렌더링 환경에 의존적인 패키지. 호스트와 react를 연결하는 역할. reconciler와 legacy-event 패키지에 의존도를 가짐
- **event**(legacy-events) : 개발자가 event를 사용하기 전, 리액트에서 추가적인 제어를 하기 위해 호스트 event를 wrapping하며 이벤트 풀링, 이벤트 위임 등을 사용하여 구현됨
- **scheduler** : 리액트는 작업(Task)을 비동기로 실행시켜야 함. Task는 우선순위에 따라 스케줄링 됨. Task의 실행 시점과 비동기 실행의 책임을 가지는 것이 scheduler. 호스트 환경에 의존적
- **reconciler** : 리액트에서 prop이나 state가 변경될 때, 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업

# 2.2 가상 DOM과 리액트 파이버

> DOM (Document Object Model) : 웹 페이지에 대한 인터페이스. 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있음
> 

## 브라우저의 렌더링 과정

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드
2. 브라우저의 렌더링 엔진이 HTML을 파싱해 DOM 노드로 구성된 트리(DOM) 생성
3. CSS를 만나면 해당 CSS 파일도 다운로드
4. 해당 CSS를 파싱해 CSS 노드로 구성된 트리(CSSOM) 생성
5. 브라우저가 DOM 노드를 순회. 눈에 보이는 노드만 방문
6. 5번 과정에서 해당 노드에 대한 CSSOM 정보를 찾고, 발견한 CSS 스타일 정보를 노드에 적용.
    - 레이아웃 : 각 노드가 브라우저 화면의 어느 좌표에 나타나야 하는지 계산하는 과정
    - 페인팅 : 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

## 가상 DOM의 탄생 배경

브라우저가 웹페이지를 렌더링하는 과정은 매우 복잡하고 많은 비용이 발생.

렌더링이 완료된 이후에도 인터랙션에 의해 웹페이지가 변경되는 상황도 고려해야 함.

ex) 특정 요소의 위치와 크기를 재계산하는 경우

- 레이아웃 + 리페인팅
- 자식 요소를 가지고 있는 경우에는 하위 요소들도 덩달아 변경되어야 함

### SPA(Single Page Application)

하나의 페이지에서 계속해서 요소의 위치를 재계산

라우팅이 변경되는 경우 대부분의 요소를 삭제 / 삽입 / 위치 계산 등의 작업 수행해야 함

⇒ 페이지의 깜빡임 없이 사용 가능 but, DOM 관리 과정에서 부담해야 할 비용 커짐

⇒ 이러한 문제점을 해결하기 위해 등장한 가상 DOM

### 가상 DOM

웹페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료되었을 때 실제 브라우저의 DOM에 반영.

⇒ DOM 계산을 브라우저가 아닌 메모리에서 계산하는 과정을 한 번 거치게 됨.

### 🤔 DOM이 가상 DOM보다 성능이 안 좋은건가요?

가상 DOM도 DOM의 복사본을 생성하고, 변화를 감지하고, 최소한의 변화를 계산하는 등의 작업을 수행해야 하므로 이 과정에서도 비용이 발생하게 된다.

따라서 변화가 많지 않은 웹 페이지에서는 실제 DOM을 사용하는 것이 더 효율적일 수 있다.

- 복잡하고 빈번한 업데이트가 필요한 웹 애플리케이션 → 가상 DOM
- 단순하고 변화가 적은 웹 페이지 → 실제 DOM

## React Fiber

> 재조정(reconciliation) : 리액트에서 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)
> 

### React Fiber가 만들어진 이유 (feat. 기존 재조정 알고리즘의 한계)

- 기존 재조정 알고리즘 = 스택 알고리즘
- 기존 가상 DOM 트리와 새로운 가상 DOM 트리를 비교하는 작업은 재귀적으로 이뤄짐
- 싱글 스레드인 자바스크립트 환경에서 스택에 렌더링에 필요한 작업들이 쌓이면 스택이 빌 때까지 다른 작업이 수행되지 못함
- 즉각적으로 유저 이벤트에 대응할 수 없을 뿐더러, 트리를 순회하는 시간이 16ms(1프레임 당 소요할 수 있는 시간)를 넘어서면 **프레임 드롭** 문제를 일으킬 수도 있음.

⇒ 자바스크립트 엔진의 `call stack` 대신 **`virtual stack`**을 통해 싱글 스레드 환경에서 동시성을 지원

> **프레임 드롭** : 작성한 코드가 16ms 이상의 시간을 소비하면서 연속적으로 실행된다면 화면이 충분히 빠르게 갱신되지 못하고 끊기는 현상
> 

리액트 파이버 구조에서는 UI 갱신 작업을 작은 단위로 나누어 내부적으로 스케줄링함으로써 대규모 UI 갱신에서도 16ms를 초과하지 않도록 한다.

![좌: 기존 재조정 알고리즘 | 우 : 파이버 알고리즘](https://prod-files-secure.s3.us-west-2.amazonaws.com/76784541-cf1f-47f0-9111-f8451ff8eafe/03673a64-b80c-429e-9678-20cf1768db65/fiber.gif)

좌: 기존 재조정 알고리즘 | 우 : 파이버 알고리즘

**리액트 파이버가 하는 일**

- 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매김 (incremental rendering)
- 위의 작업은 일시 중지하고 나중에 다시 시작 가능
- 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기 가능

### 변경된 재조정 단계

1. **Render** : 두 fiber 트리를 비교하고 변경된 이펙트를 수집하는 작업. 렌더 단계에서는 일시 정지되고 재실행 될 수 있음. 리액트 스케줄러로 인해 수서로 멈춰서 메인 스레드에 사용자 입력, 애니메이션 같은 더 급한 작업이 있는지 확인해가며 실행. 
2. **Commit** : DOM에 실제 변경 사항을 반영하기 위한 작업이 실행됨. 동기식으로 일어남. 중단 불가

- 파이버는 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적이면 재사용됨
- 파이버는 state 변경, 생명주기 메서드 실행, DOM 변경이 필요한 시점에 실행됨

[기존 재조정 트리 탐색](https://codepen.io/ejilee/pen/ZExPQRE)

기존 재조정 트리 탐색

[파이버 재조정 트리 탐색](https://codepen.io/ejilee/pen/eYMXJPN)

파이버 재조정 트리 탐색

[출처 : 콴다 팀 블로그 - React Deep Dive — Fiber](https://blog.mathpresso.com/react-deep-dive-fiber-88860f6edbd0)

### 리액트 파이버의 주요 속성

- `tag` : 요소와 파이버의 1:1 매칭 정보. 요소는 리액트 컴포넌트 외에 다른 것들이 될 수 있음.
- `stateNode` : 파이버 자체에 대한 참조 정보. 참조를 바탕으로 파이버와 관련된 상태에 접근
- `child`, `sibling`, `return` : 파이버 간의 관계 개념
    - 리액트 컴포넌트 트리와 다르게 children이 아닌 하나의 child만 존재
    - `child` : 첫 번째 자식 요소
    - `sibling` : 나머지 자식 요소
    - `return` : 부모 파이버
- `index` : 여러 형제들 사이에서의 자신의 위치
- `pendingProps` : 아직 작업을 처리하지 못한 props
- `memoizedProps` : 렌더링이 완료된 이후에 `pendingProps`를 `memoizedProps`로 저장해 관리
- `updateQueue` : 상태 업데이트, 콜백 함수, DOM 업데이트 등 필요한 작업을 담아두는 큐
- `memoizedState` : 함수형 컴포넌트의 훅 목록
- `alternate` : 반대편 트리 파이버를 가리킴

### 리액트 파이버 트리

파이버 트리는 현재 모습을 담은 `flushed fiber` 트리, 작업 중인 상태를 나타내는(화면 반영 X) `workInProgress fiber` 트리 두 개가 존재한다.

리액트 파이버의 작업이 끝나면 리액트는 단순히 포인트만 변경해 workInProgress 트리를 현재 트리로 바꿔버린다. (더블 버퍼링) (커밋 단계에서 수행)

> 더블 버퍼링 : 보이지 않는 곳에서 그 다음으로 그려야 할 그림을 미리 그린 다음, 완성되면 현재 상태를 새로운 그림으로 바꾸는 기법
> 

![리액트 파이버 트리](https://prod-files-secure.s3.us-west-2.amazonaws.com/76784541-cf1f-47f0-9111-f8451ff8eafe/14be8ed7-bf5f-4249-b7c1-ecb98291e724/Untitled.png)

리액트 파이버 트리

### 파이버의 작업 순서

1. beginWork() 함수를 실행해 파이버 작업 수행. 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작됨
2. 1번 작업이 끝나면 completeWork() 함수 실행해 파이버 작업 완료 (DOM 인스턴스 완성)
3. 형제가 있다면 형제로 넘어감
4. 작업이 모두 끝나면 return으로 돌아가 자신의 작업이 완료됨을 알림
5. 루트 노드가 완성되는 순간, 최종적으로 commitWork()가 수행되고 변경 사항을 비교해 업데이트가 필요한 변경 사항이 DOM에 반영됨

### 리액트 파이버의 작업 우선 순위

1. 동기적 (Synchronous) : 작업이 즉시 실행되어야 하며, 다른 작업들을 차단한다. `ReactDOM.render()` 또는 `ReactDOM.flushSync()` 함수 호출에 의해 발생
2. 사용자 블로킹 (User-Blocking) : 사용자가 직접적으로 인터랙션하는 작업
3. 정규 (Normal) : 대부분의 업데이트 작업
4. 아이들 (Idle) : 시간이 허락하는 대로 처리할 수 있는 작업. pre-fetching이나 미사용 UI의 렌더링 등의 작업
