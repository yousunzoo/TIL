# 230202 자료구조 수업

## 해시 테이블

* 해시 테이블 정의
  * 연관 배열 구조 자료구조
  * 키(key)를 이용하여 값(value)을 알 수 있음
* 장점
  * 빠른 데이터 읽기, 삽입, 삭제 => `O(1)`
  * 해쉬 함수를 통하여 공간을 효율적으로 사용
* 단점
  * 메모리를 많이 차지하고 충돌 위험 O
  * 이미 해당 인덱스에 값이 있는데 값을 추가할 경우 충돌 발생

| 키(key)       | 해시 함수   | 인덱스 | 값     |
| ------------- | ----------- | ------ | ------ |
| 안경 쓴 펭귄  | 펭귄 => 1   | 1      | 뽀로로 |
| 무서운 북극곰 | 북극곰 => 2 | 2      | 포비   |
| 요리하는 비버 | 비버 => 3   | 3      | 루피   |



## 해시 테이블 예시

* 전화번호부 단축키

| 순서     | 1             | 2             | 3             |
| -------- | ------------- | ------------- | ------------- |
| 이름     | 철수          | 맹구          | 유리          |
| 전화번호 | 010-1234-**** | 010-1234-**** | 010-1234-**** |

Q. 유리한테 전화를 걸고 싶을 때 무엇으로 찾아야 가장 빠를까?

A. 3번에 등록해 놓고 바로 전화를 하는 것이 가장 빠르다. 이처럼 Key와 Value를 인덱스에 저장해놓고 빠르게 찾는 자료 구조 형태를 해시 테이블이라고 한다.



### 해시 함수

* 키를 해시(Hash)로 바꿔준다.
* 여러 키를 분할하기 위해 키를 해시 값(정수 값)으로 매칭시키는 역할을 함
* 다양한 길이를 가지고 있는 키를 일정한 길이를 가지는 해시로 바꿔줌
* 해시는 곧 인덱스가 되고 해당 인덱스에 값이 저장되게 된다.
* 저장소 효율적으로 운영 가능

* 해시 사용 사례 : 비밀번호 해시화, 개인정보 유출 방지



## 체이닝

* 충돌 시 연결 리스트에 추가하는 방식
* 중복된 해시 값이 있는 경우, 해당 슬롯을 연결 리스트로 저장 (충돌 해결)
* 연결 리스트로 인해 최악의 경우 수행 시간이 O(n)이 됨



### 개방 주소법

1) 선형 탐색(순차적 탐색) : 해시 충돌 시 다음 버킷에 저장
2) 제곱 탐색 : 해시 충돌 시 제곱만큼 건너 뛴 버킷에 데이터를 저장
3) 이중 해시 : 해시 충돌 시 다른 해시함수를 한 번 더 적용한 결과 저장





## 셋

* 데이터의 중복을 허용하지 않는 자료구조
* 해시 테이블을 사용해서 Hash Set이라고도 불림
* 자료 접근 시 인덱스 값은 사용하지 않고 키만 사용
* 인덱스, 즉 순서가 존재하지 않음
* 장점
  * 충돌이 날 경우가 없음
  * 빠른 속도로 검색 가능

| 키            | 값     |
| ------------- | ------ |
| 안경 쓴 펭귄  | 뽀로로 |
| 무서운 북극곰 | 포비   |
| 요리하는 비버 | 루     |



### 셋의 추상자료형

| index | Method name | Params | rule            |
| ----- | ----------- | ------ | --------------- |
| 1     | add         | {data} | 데이터 삽입     |
| 2     | iscontain   | {data} | 데이터 확인     |
| 3     | remove      | {data} | 데이터 제거     |
| 4     | clear       | {}     | 셋 비우기       |
| 5     | isEmpty     | {}     | 비어있는지 확인 |
| 6     | printAll    | {}     | 모든 요소 출력  |



## 셋 In JavaScript

```javascript
const Newset = [...new Set([1,1,2,3,3])];
console.log(Newset); // [1,2,3]
```

* Set의 모든 값은 고유하다.
  * 배열에서 중복 항목을 제거하는 데 사용됨
* 배열과 비교했을 때 주요한 장점 : Set이 값을 포함하고 있는지 더욱 효율적으로 확인 가능



### 해시 셋과 해시 테이블 비교

|                   |           해시 셋           |         해시 테이블          |
| :---------------: | :-------------------------: | :--------------------------: |
| 데이터 추출 형태  | Data 추출은 Iterator를 이용 | Data 추출은 key-Value를 이용 |
|     중복 허용     |              X              |              O               |
|       index       |              X              |              O               |
| 키 값에 null 허용 |              O              |              X               |
|      동기화       |          비동기화           |            동기화            |

* 스레드 동기화가 필요하지 않은 경우 일반적으로 HashMap이 HashTable보다 선호된다.





## Object와 Map 비교

| 구분      | Object                                                   | Map                                                  |
| --------- | -------------------------------------------------------- | ---------------------------------------------------- |
| 키의 타입 | string, symbol                                           | 모든 값                                              |
| 크기      | 수동으로 추적                                            | 내부 프로퍼티(Size)                                  |
| 사용 경우 | 적용해야 하는 로직이 있는 경우 (`Object.defineProperty`) | 실행 시 키를 알 수 없고 모든 키와 값들이 동일한 경우 |

* Map은 삽입된 순서대로 반복된다.
* Map의 경우 이터러블 객체가 반환되어 `for ... of` 함수를 사용할 수 있고, 배열 스프레드 오퍼레이터와 배열 비구조화 할당을 사용할 수 있다.





## Set과 Array 비교

| 구분        | Set    | Array |
| ----------- | ------ | ----- |
| 중복 허용   | O      | X     |
| 인덱스 참조 | 불가능 | 가능  |

* Set 생성자를 가지고 생성한 이터러블 객체는 `getter`만을 가지고 있어 읽기 전용이다.
* `length` 프로퍼티에 대해 수정할 수 있다. `Array.prototype.length`는 `setter`를 가지고 있다.
  * 직접 `length`를 수정하게 되면 요소의 개수와 배열의 길이가 다른 희소 배열이 생성된다.
