# 230202 자료구조 수업

## 해시 테이블

* 해시 테이블 정의
  * 연관 배열 구조 자료구조
  * 키(key)를 이용하여 값(value)을 알 수 있음
  * 키와 1차원 배열의 인덱스 관계를 이용하여 키(항목)를 저장
  * 키를 배열의 인덱스로 그대로 사용하게 되면 메모리 낭비가 심해질 수 있음
    * 해결 방안) 키를 해시로 변환하여 배열의 인덱스로 사용
* 장점
  * 빠른 데이터 읽기, 삽입, 삭제 => `O(1)`
  * 해쉬 함수를 통하여 공간을 효율적으로 사용
* 단점
  * 메모리를 많이 차지하고 충돌 위험 O
  * 이미 해당 인덱스에 값이 있는데 값을 추가할 경우 충돌 발생

| 키(key)       | 해시 함수   | 인덱스 | 값     |
| ------------- | ----------- | ------ | ------ |
| 안경 쓴 펭귄  | 펭귄 => 1   | 1      | 뽀로로 |
| 무서운 북극곰 | 북극곰 => 2 | 2      | 포비   |
| 요리하는 비버 | 비버 => 3   | 3      | 루피   |

![image-20230202174525890](../images/230202-TIL/image-20230202174525890.png)





### 해시 테이블 예시

* 전화번호부 단축키

| 순서     | 1             | 2             | 3             |
| -------- | ------------- | ------------- | ------------- |
| 이름     | 철수          | 맹구          | 유리          |
| 전화번호 | 010-1234-**** | 010-1234-**** | 010-1234-**** |

Q. 유리한테 전화를 걸고 싶을 때 무엇으로 찾아야 가장 빠를까?

A. 3번에 등록해 놓고 바로 전화를 하는 것이 가장 빠르다. 이처럼 Key와 Value를 인덱스에 저장해놓고 빠르게 찾는 자료 구조 형태를 해시 테이블이라고 한다.



### 해시 함수

* 키를 해시(Hash)로 바꿔준다.
* 여러 키를 분할하기 위해 키를 해시 값(정수 값)으로 매칭시키는 역할을 함
* 다양한 길이를 가지고 있는 키를 일정한 길이를 가지는 해시로 바꿔줌
* 해시는 곧 인덱스가 되고 해당 인덱스에 값이 저장되게 된다.
* 저장소 효율적으로 운영 가능

* 가장 이상적인 해시 함수 : 키들을 균등하게 해시 테이블의 인덱스로 변환하는 함수(랜덤하게 흩어지도록 저장)

* 해시 사용 사례 : 비밀번호 해시화, 개인정보 유출 방지



#### 대표적인 해시 함수

1. 중간 제곱(Mid-square) 함수

   * 키를 제곱한 후, 적절한 크기의 중간 부분을 해시 값으로 사용

2. 접기(Folding) 함수

   * 큰 자릿수를 갖는 십진수를 키로 사용하는 경우
   * 몇 자리씩 일정하게 끊어서 만든 숫자들의 합을 이용해 해시값 생성

3. 곱셈(Multiplicative) 함수

   * 1보다 작은 실수 δ를 키에 곱하여 얻은 숫자의 소수 부분을 테이블 크기 M과 곱해서 나온 값의 정수 부분을 해시 값으로 사용

   * $$
     h(key) = (int) (key * δ)/1*M
     $$

4. 나눗셈(Division) 함수

   * 키를 소수(Prime) M으로 나눈 뒤, 나머지를 해시 값으로 사용
   * `h(key) = key % M`. 따라서 해시 테이블의 인덱스는 0에서 M-1
   * 가장 널리 사용되는 해시 함수



### 충돌(Collision)

* 아무리 우수한 해시 함수를 사용하더라도 2개 이상의 항목을 해시 테이블의 동일한 요소에 저장해야 하는 경우 발생
* 서로 다른 키들이 동일한 해시 값을 가질 때 충돌 발생





### 충돌 해결 방법

#### 개방 주소법(Open Addressing)

* 해시 테이블 전체를 열린 공간으로 가정하고 충돌된 키를 일정한 방식에 따라서 찾아낸 empty 원소에 저장

1) 선형 탐색(순차적 탐색) : 해시 충돌 시 다음 버킷에 저장
2) 제곱 탐색 : 해시 충돌 시 제곱만큼 건너 뛴 버킷에 데이터를 저장
3) 이중 해시 : 해시 충돌 시 다른 해시함수를 한 번 더 적용한 결과 저장



#### 폐쇄 주소법(Closed Addressing)

* 키에 대한 해시 값에 대응되는 곳에만 키를 저장
  * 충돌이 발생한 키들은 한 위치에 모여 저장
  * 이를 구현하는 가장 대표적인 방법 : 체이닝(Chaining)



##### 체이닝

* 충돌 시 연결 리스트에 추가하는 방식
* 중복된 해시 값이 있는 경우, 해당 슬롯을 연결 리스트로 저장 (충돌 해결)
* 연결 리스트로 인해 최악의 경우 수행 시간이 O(n)이 됨





## 셋(Set)

* 데이터의 중복을 허용하지 않는 자료구조
* Set은 집합이라는 의미를 가
* 해시 테이블을 사용해서 Hash Set이라고도 불림
  * 입력된 키를 해시로 변환
  * 해시 코드를 인덱스로 한 배열에 해당 인덱스를 찾아 값 저장
  * 배열 길이가 초과되는 경우에는 길이의 나머지를 구해 링크드 리스트로 추가

* 자료 접근 시 인덱스 값은 사용하지 않고 키만 사용
* 인덱스, 즉 순서가 존재하지 않음
* 장점
  * 충돌이 날 경우가 없음
  * 빠른 속도로 검색 가능

| 키            | 값     |
| ------------- | ------ |
| 안경 쓴 펭귄  | 뽀로로 |
| 무서운 북극곰 | 포비   |
| 요리하는 비버 | 루     |





### 셋의 추상자료형

| index | Method name | Params | rule            |
| ----- | ----------- | ------ | --------------- |
| 1     | add         | {data} | 데이터 삽입     |
| 2     | iscontain   | {data} | 데이터 확인     |
| 3     | remove      | {data} | 데이터 제거     |
| 4     | clear       | {}     | 셋 비우기       |
| 5     | isEmpty     | {}     | 비어있는지 확인 |
| 6     | printAll    | {}     | 모든 요소 출력  |



## 셋 In JavaScript

```javascript
const Newset = [...new Set([1,1,2,3,3])];
console.log(Newset); // [1,2,3]
```

* Set의 모든 값은 고유하다.
  * 배열에서 중복 항목을 제거하는 데 사용됨
* 배열과 비교했을 때 주요한 장점 : Set이 값을 포함하고 있는지 더욱 효율적으로 확인 가능



### 해시 셋과 해시 테이블 비교

|                   |           해시 셋           |         해시 테이블          |
| :---------------: | :-------------------------: | :--------------------------: |
| 데이터 추출 형태  | Data 추출은 Iterator를 이용 | Data 추출은 key-Value를 이용 |
|     중복 허용     |              X              |              O               |
|       index       |              X              |              O               |
| 키 값에 null 허용 |              O              |              X               |
|      동기화       |          비동기화           |            동기화            |

* 스레드 동기화가 필요하지 않은 경우 일반적으로 HashMap이 HashTable보다 선호된다.





## Object와 Map 비교

| 구분      | Object                                                   | Map                                                  |
| --------- | -------------------------------------------------------- | ---------------------------------------------------- |
| 키의 타입 | string, symbol                                           | 모든 값                                              |
| 크기      | 수동으로 추적                                            | 내부 프로퍼티(Size)                                  |
| 사용 경우 | 적용해야 하는 로직이 있는 경우 (`Object.defineProperty`) | 실행 시 키를 알 수 없고 모든 키와 값들이 동일한 경우 |

* Map은 삽입된 순서대로 반복된다.
* Map의 경우 이터러블 객체가 반환되어 `for ... of` 함수를 사용할 수 있고, 배열 스프레드 오퍼레이터와 배열 비구조화 할당을 사용할 수 있다.





## Set과 Array 비교

| 구분        | Set    | Array |
| ----------- | ------ | ----- |
| 중복 허용   | O      | X     |
| 인덱스 참조 | 불가능 | 가능  |

* Set 생성자를 가지고 생성한 이터러블 객체는 `getter`만을 가지고 있어 읽기 전용이다.
* `length` 프로퍼티에 대해 수정할 수 있다. `Array.prototype.length`는 `setter`를 가지고 있다.
  * 직접 `length`를 수정하게 되면 요소의 개수와 배열의 길이가 다른 희소 배열이 생성된다.
