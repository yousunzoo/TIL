# Array

## 객체의 Big O

* 객체는 정렬될 필요가 없을 때 잘 작동한다.
* 빠른 접근, 입력과 제거를 원할 때 좋다.
  * 입력, 제거, 접근하는 시간이 상수 시간(`O(1)`)이다.

* 그러나 탐색은 선형 시간(`O(N)`)이다.
  * 탐색은 어떤 특정한 정보가 어떤 값에 있는지 일일이 확인하는 것이다.



### 객체 메소드의 Big O

| 객체 메소드    | 시간 복잡도 |
| -------------- | ----------- |
| Object.keys    | O(N)        |
| Object.values  | O(N)        |
| Object.entries | O(N)        |
| hasOwnProperty | O(1)        |





## 배열 안의 데이터에 접근이 느린 이유

* 배열은 데이터가 정렬되어 있다.

* 배열에 있는 데이터를 접근하는 것은 매우 빠르다.
  * 인덱스가 있기 때문에 빠르게 접근할 수 있다.
  * 하나씩 순차적으로 데이터를 거쳐가는게 아니라 해당 인덱스 주소로 이동한다.
* 입력과 제거는 느리다.
  * 데이터를 배열 앞에서 추가/제거를 하게 된다면 배열에 있는 요소마다 인덱스를 새로 부여해야 한다. ➡️ N의 크기에 따라 시간이 달라진다.



### 배열의 Big O

| 기능      | 시간 복잡도   |
| --------- | ------------- |
| Insertion | It depends... |
| Removal   | It depends... |
| Searching | O(N)          |
| Access    | O(1)          |





### 배열 메소드의 Big O

| 배열 메소드                      | Big O      |
| -------------------------------- | ---------- |
| push                             | O(1)       |
| pop                              | O(1)       |
| shift                            | O(N)       |
| unshift                          | O(N)       |
| concat                           | O(N)       |
| slice                            | O(N)       |
| splice                           | O(N)       |
| sort                             | O(N*log N) |
| forEach/map/filter/reduce/etc... | O(N)       |

* concat - 뒤에 붙일 배열의 크기가 클수록 시간도 그만큼 늘어나게 된다.

* slice - 얼마나 많은 갯수를 복사하느냐에 따라 시간도 그만큼 늘어난다.
* splice - 배열 중간에 요소를 추가하게 된다면 O(N)으로 표현하게 된다.
* 일반적으로 배열과 관련된 작업들은 O(N)이다.
* sort - 비교를 해야 하고, 요소들을 이동해야 하고 정렬하려면 O(N)보다 더 큰 값을 가지게 된다.