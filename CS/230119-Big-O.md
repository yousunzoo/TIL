# Big O 표기법

## 개념

* 숫자로 코드의 성능을 표기할 수 있다.
* 보통 알고리즘의 시간 복잡도와 공간 복잡도를 나타내는데 주로 사용된다.
* 입력된 내용이 늘어날 수록 알고리즘에 실행 시간이 어떻게 변하는지 설명하는 공식적인 방식
* 어떤 함수의 입력 크기와 실행 시간의 관계를 말한다.
* 오로지 전반적인 추세를 말한다.
* 빅오는 실행 시간이 가질 수 있는 최대치를 측정한다.
* 연산의 개수에 따라 실행 시간이 달라진다. => 표기법이 달라진다.



### 코드의 성능이 좋다는 것은?

* 속도가 빠른 것?
  * but, 기기마다 성능이 다르기 때문에 책정되는 시간이 기기마다, 실행되는 프로그램마다 다를 수 있음
  * 심지어 같은 브라우저에서 실행시켜도 다르게 나올 때가 많다.
  * 빠른 알고리즘에서는 정말 짧은 시간 안에 모든 것이 다 처리된다.
  * 이런 경우 시간을 측정하는 것으로 코드의 성능을 판단할 순 없다.
  * 그래서 빅오 표기법이 등장!
* 메모리 사용이 적은 것?
* 쉽게 읽을 수 있는 것?



## Big O 표기

* `O(1)` : `n`의 값이 커져도 실행 시간에 변화 없음.

  ```javascript
  function addUpTo(n) {
      return n * (n+1) / 2;
  }
  ```

  

* `O(n)` : `n`의 값이 늘어날 수록 연산의 갯수도 비례
  * 연산의 갯수는 궁극적으로 `n`의 곱과 연결됨
  * 실질적으로 곱이 `5n`이 되더라도 `n`으로 단순화 가능

```javascript
function addUpTo(n) {
    let total = 0;
    for (let i = 0; i <= n; i++){
        total += i;
    }
    return total;
}
```



* `O(n^2)` : `n`이 커질수록 실행 시간이 `n` 제곱의 값으로 늘어남
  * 루프 함수 안에 또 다른 루프 함수가 있는 경우 (중첩)

```javascript
function printAllPairs(n) {
    for (var i=0; i < n; i++){
        for (var j=0; j < n; j++){
            console.log(i,j);
        }
    }
}
```





## 시간 복잡도

* 입력이 커질수록 알고리즘의 실행 속도가 어떻게 바뀌는지 분석한다.
* `5n + 2` 식은 `n`으로 단순화한다.
  * `n`이 커질 수록 실행 시간도 비례하게 늘어날 것이고, `2n` 이든 `9n`이든 추세(그래프의 선)가 `n`의 값과 비례하다.
* 속도 비교 : (느린 순) `O(n^2)` > `O(n)` > `O(1)` (빠른 순)



### 단순화 규칙

* 상수는 중요하지 않다.
  * `O(500)`은 `O(1)` 로 단순화 한다.
    * `O(500)`은 `n`이 무엇이든 간에 연산 갯수가 500이다.
    * 따라서 그래프 선은 납작하다.
    * `O(1)`과 추세가 같기 때문에 상수는 `O(1)`로 단순화한다.
    * `O(13n^2)`도 마찬가지로 상수를 무시하고 `O(n^2)`로 단순화한다.
* 작은 연산도 중요하지 않다.
* 산수(덧셈, 뺄셈, 곱셈, 나눗셈)은 상수에 포함된다.
  * `O(n + 10)`은 `O(n)`으로 단순화한다.
  * `O(1000n + 50)`도 `O(n)`으로 단순화한다.
  * `O(n^2 + 5n + 8)`도 `O(n)`으로 단순화한다.
    * 작은 수를 사용했을 땐 단순화한 수와의 차이가 있어보일 순 있지만, 빅오에서는 최대값을 표시하기 때문에 n이 억대로 간다 치면 매우 적은 차이밖에 나지 않는다. 따라서 `O(n)`으로 단순화한다.





#### 예제 1

n이 5 이하면 1부터 5까지 출력하고 6 이상이면 1부터 n까지 출력한다.

```javascript
function logAtLeast5(n) {
    for (var i = 1; 1 <= Math.max(5,n); i++) {
        console.log(i);
    }
}
```

* n이 5보다 작은 경우는 무시해도 된다.
* 주목해야 할 것은 `n`이 계속해서 커지는 경우이다.
* `n`이 커질수록 연산 갯수가 `n`에 비례해서 늘어나기 때문에 `O(n)`으로 단순화할 수 있다.



#### 예제 2

n이 5 이상이면 1부터 5까지만 출력하고 5 미만이면 1부터 n까지 출력한다.

```javascript
function logAtMost5(n) {
    for (var i = 1; 1 <= Math.min(5,n); i++) {
        console.log(i);
    }
}
```

* n이 계속해서 커져도 `i`의 값은 5를 넘지 않을 것이다.
* 그렇기 때문에 `n`이 커질수록 빅 오는 `O(1)`이라고 단순화 할 수 있다.



![image-20230119170854671](../images/230119-Big-O/image-20230119170854671.png)



## 공간 복잡도

* 입력이 커질수록 알고리즘이 얼마나 많은 공간을 차지하는지 분석한다.
* `n`이 커질수록 무한대까지 가면서 당연히 입력 자체가 커지기 때문에 입력되는 것은 제외하고 **알고리즘 자체가 필요로 하는 공간**을 분석한다. ( = 보조 공간 복잡도)



### 기본적인 규칙

* `booleans`, `numbers`, `null`, `undefined`는 자바스크립트에서 모두 불변 공간이다. (constance space)
* `String`은 문자열의 길이에 따라 공간 차지가 달라진다. (`O(n)` space)
* 참조 타입(`Object`, `Array`)도 길이에 따라 공간 차지가 달라진다. (`O(n)` space)
  * `n`은 배열의 길이이거나 객체의 키 개수일 수 있다.



#### 예제 1

배열의 모든 값을 더하는 함수

```javascript
function sum(arr) {
    let total = 0;
    for (let i = 0; i < arr.length; i++){
        total += arr[i];
    }
    return total;
}
```

* 공간을 차지하는 것들 : 변수 (`total`, `i`)
  * 위 예제의 변수들은 배열의 크기와는 상관 없이 어떤 상황에도 값이 유지된다. 
    * 즉, 상수 공간이 있다는 것을 의미한다. (`O(1)` space)



#### 예제 2

배열의 값에 2를 곱해 배열 반환하는 함수

```javascript
function double(arr) {
    let newArr = [];
    for (let i = 0; i < arr.length; i++) {
        newArr.push(2*arr[i]);
    }
    return newArr;
}
```

* `newArr`가 차지하는 공간은 `arr`의 크기와 비례해서 커지게 된다.
  * `O(n)` space를 가지게 된다.





