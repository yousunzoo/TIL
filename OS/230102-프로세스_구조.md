# 프로세스 구조

* 프로그램 : 컴파일한 코드와 초기화 전역변수, 문자열과 문자열 상수 등 정적 데이터를 포함하는 정적인 개체
* 프로세스 : 프로그램 카운터나 레지스터처럼 현재 어떤 자원을 사용하는지 관련 정보가 들어있는 동적인 개체
  * 실행 중인 프로그램을 말함



### 프로세스 메모리 구조

* text(CODE) : 실행할 프로그램의 코드가 기계어 형태로 변환되어 저장됨.
  * CPU는 이 영역에서 명령어를 하나씩 가져와 처리하게 됨
  * 컴파일 타임에 결정되고 중간에 코드를 바꿀 수 없게 Read-only로 되어있음
* data : 전역변수와 정적변수가 저장됨
  * 변수는 프로그램이 시작될 때 할당되어 프로그램 종료 시 소멸됨
  * 전역변수 또는 정적변수를 참조한 코드는 컴파일이 완료되면 data 영역의 주소값을 가리키도록 바뀜
  * 전역변수가 변경될 수도 있어 Read-Write로 되어있음
* stack : 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터(지역변수, 매개변수, 리턴값 등)를 임시로 저장하는 공간
  * 함수 호출 시 할당되고 함수 수행 완료 시 소멸됨
  * 로드 시(컴파일 타임) 크기가 결정됨
  * LIFO(Last In First Out) 방식을 따름
  * 재귀함수가 반복해서 호출되거나 함수가 지역변수를 메모리를 초과할 정도로 너무 많이 가지고 있다면 stack overflow 발생
* heap : 프로그래머가 필요할 때마다 사용하는 메모리 영역
  * 힙 영역에서 `malloc()` 또는 `new` 연산자를 통해 메모리를 할당하고, `free()` 또는 `delete` 연산자를 통해 메모리를 해제
  * FIFO(First In First Out) 방식을 따름
  * 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됨
  * 프로그램 동작 시(런타임)에 크기가 결정됨

![프로세스(Process)](https://blog.kakaocdn.net/dn/berUN5/btrejfCRS7h/EOJKBxxk7eqB9lbaOmDC71/img.png)





### 프로세스와 프로그램의 동작



![img](https://velog.velcdn.com/images%2Funderlier12%2Fpost%2F4e0925c8-3544-45d6-9e83-90734321a7fa%2Fimage.png)



* 프로그램이 실행되면 프로세스의 CODE 영역에 코드들이 전달된다.
* 이후 PC(Program Counter)가 코드가 존재하는 주소(메모리 주소)를 하나하나 가리키며 순서대로 실행이 되고 실행 중 stack, heap, data 영역에 read/write를 실시한다.



![img](https://velog.velcdn.com/images%2Funderlier12%2Fpost%2F9ebe6d45-8993-4d03-9c14-595d6cb643d4%2Fimage.png)



* stack 내의 return address는 함수 내에 함수가 존재하는 경우도 있기 때문에 그런 경우 return address를 지정하여 내부 함수 동작이 끝나면 다시 외부 함수로 돌아가 작업이 이어지도록 한다.
* 일련의 연산 과정이 끝나면 stack에서 차례대로 다시 제거가 되며 이후 모든 작업이 완료되었을 경우 stack, heap, data에는 아무것도 남지 않고 프로그램이 종료된다.





### PCB(프로세스 제어 블록)

* 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳
* 프로세스의 상태 정보를 저장하는 구조체
* 프로세스 상태 관리와 컨텍스트 스위칭을 위해 필요
* PCB는 프로세스 생성 시 만들어지며 주기억장치에 유지





---

## 참고

* [메모리의 구조(코드, 데이터, 힙, 스택 영역)](https://all-young.tistory.com/17)
* [프로세스 메모리 구조(코드, 데이터, 스택, 힙)](https://zangzangs.tistory.com/107)



