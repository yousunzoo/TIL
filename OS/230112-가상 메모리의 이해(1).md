# 가상 메모리의 이해

## 가상 메모리 개념

> 실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있다.

> 폰노이만 구조 기반이므로, 코드는 메모리에 반드시 있어야 함



### 가상 메모리가 필요한 이유

* 하나의 프로세스만 실행 가능한 시스템 (배치 처리 시스템 등)
  1. 프로그램을 메모리로 로드
  2. 프로세스 실행
  3. 프로세스 종료 (메모리 해제)
* 여러 프로세스 동시 실행 시스템
  1. 메모리 용량 부족 이슈
  2. 프로세스 메모리 영역 간에 침범 이슈



## 가상 메모리 (Virtual Memory System)

* 가상 메모리 : 메모리가 실제 메모리보다 많아 보이게 하는 기술
  * 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술
  * 프로세스 간 공간 분리로, 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있음
* 가상 메모리 기본 아이디어
  * 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고 쓸 때만 물리 주소로 바꿔주면 된다.
  * virtual address (가상 주소) : 프로세스가 참조하는 주소
  * physical address (물리 주소) : 실제 메모리 주소
* MMU (Memory Management Unit)
  * CPU에 코드 실행 시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치
* 메인 메모리에 실제 각 프로세스의 데이터가 조각으로 씌여 있다.





### 가상 메모리와 MMU

* CPU는 가상 메모리를 다루고, 실제 해당 주소 접근 시 MMU 하드웨어 장치를 통해 물리 메모리 접근
  * 하드웨어 장치를 이용해야 주소 변환이 빠르기 때문에 별도 장치를 둠

* CPU -> MMU -> Memory





---

## 페이징 시스템

* 페이징(paging) 개념
  * 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
  * 하드웨어 지원이 필요
    * 예) Intel x86 시스템(32bit)에서는 4KB, 2MB, 1GB 지원
  * 리눅스에서는 4KB로 paging
  * 페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용



> 실질적인 예를 기반으로 페이징 시스템 알아보기

* 프로세스 (4GB)의 PCB에 Page Table 구조체를 가리키는 주소가 들어 있음
* Page Table에는 가상 주소와 물리 주소 간 매핑 정보가 있음





### 페이징 시스템 구조

* page 또는 page frame : 고정된 크기의 block (4KB)
* paging system
  * 가상 주소 v = (p, d)
    * p : 가상 메모리 페이지
    * d : p 안에서 참조하는 위치 
* 페이지 크기가 4KB일 때의 예
  * 가상 주소의 0비트에서 11비트가 변위(d)를 나타내고, 12비트 이상이 페이지 번호가 될 수 있음



#### 모든 것은 결국 bit와 연결

* 프로세스가 4GB를 사용하는 이유 - 32bit 시스템에서 2^32이 4GB





### 페이지 테이블(page table)

* page table
  * 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표
  * 가상주소 `v = (p, d)`라면
    * p : 페이지 번호
    * d : 페이지 처음부터 얼마 떨어진 위치인지
* paging system 동작
  * 해당 프로세스에서 특정 가상 주소 액세스를 하려면
    * 해당 프로세스의 page table에 해당 가상 주소가 포함된 page 번호가 있는지 확인
    * page 번호가 있으면 이 page가 매핑된 첫 물리 주소를 알아내고(p')
    * p' + d 가 실제 물리 주소가 됨





### 페이징 시스템과 MMU(컴퓨터 구조)

* CPU는 가상 주소 접근 시
  * MMU 하드웨어 장치를 통해 물리 메모리 접근
* 프로세스 생성 시, 페이지 테이블 정보 생성
  * PCB 등에서 해당 페이지 테이블 접근 가능하고, 관련 정보는 물리 메모리에 적재
  * 프로세스 구동 시, 해당 페이지 테이블 base 주소가 별도 레지스터에 저장(CR3)
  * CPU가 가상 주소 접근 시, MMU가 페이지 테이블 base 주소를 접근해서 물리 주소를 가져옴