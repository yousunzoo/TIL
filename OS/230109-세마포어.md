# 동기화와 세마포어

## 동기화 이슈

* 동기화 : 작업들 사이에 실행 시기를 맞추는 것
* 여러 스레드가 동일한 자원(데이터) 접근시 동기화 이슈 발생
  * 동일 자원을 여러 스레드가 동시 수정 시, 각 스레드 결과에 영향을 줌



## 동기화 이슈 해결 방안

* Mutual exclusion (상호 배제)
* 스레드는 프로세스 모든 데이터를 접근할 수 있으므로,
  * 여러 스레드가 변경하는 공유 변수에 대해 Exclusive Access 필요
  * 어느 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 동시 접근하지 못하도록 막아야 함



### Mutual exclusion

* 임계 자원(critical resource)
* 임계 영역(critical section)
  * 다중 프로그래밍 운영체제에서 여러 프로세스가 데이터를 공유하면서 수행될 때 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분



## Mutex와 세마포어 (Semaphore)

* Critical Section(임계 구역)에 대한 접근을 막기 위해 LOCKING 메커니즘이 필요

  * Mutex (binary semaphore)

    : 임계 구역에 하나의 스레드만 들어갈 수 있음

    : 공유된 자원의 데이터 혹은 임계 구역 등에 하나의 Process 혹은 Thread가 접근하는 것을 막아줌(동기화 대상이 하나)

  * Semaphore

    : 임계 구역에 여러 스레드가 들어갈 수 있음

    : counter를 두어서 동시에 리소스에 접근할 수 있는 허용 가능한 스레드 수를 제어

    : 공유된 자원의 데이터 혹은 임계 구역 등에 여러 Process 혹은 Thread가 접근하는 것을 막아줌 (동기화 대상이 하나 이상)



### 세마포어

* P : 검사 (임계 영역에 들어갈 때)
  * S 값이 1 이상이면 임계 영역 진입 후, S값 1 차감 (S값이 0이면 대기)
* V : 증가 (임계 영역에서 나올 때)
  * S 값을 1 더하고 임계 영역을 나옴
* S : 세마포어 값 (초기 값만큼 여러 프로세스가 동시 임계 영역 접근 가능)

```c
P(S) : wait(S) {
    			while S <= 0 // 바쁜 대기
                ;
   	  S--;      // 다른 프로세스 접근 제한
}

V(S) : signal(S) {
    	S++;   // 다른 프로세스 접근 허용
}
```



#### 세마포어 - 바쁜 대기

* wait()은 S가 0이라면, 임계 영역에 들어가기 위해 반복문 수행

  ➡️ 바쁜 대기

```C
P(S) : wait(S) {
    			while S <= 0 // 바쁜 대기
                ;
    	S--;    // 다른 프로세스 접근 제한
}
```



#### 짚고 넘어가기

* 프로그래밍은 근본적으로는 중단이 없음. 끊임없이 코드 실행
  * 중단은 대부분 loop로 표현
  * loop는 CPU에 부하를 걸리게 함





#### 세마포어 - 대기 큐

* S가 음수일 경우, 바쁜 대기 대신 대기 큐에 넣는다.

```c
wait(S) {
    	S->count--;
    if (S->count <= 0) {
        add this process to S->queue;
        block()
    }
}
```



* wakeup() 함수를 통해 대기 큐에 있는 프로세스 재실행

```C
signal(S) {
    	S->count++;
    if (S->count > 0) {
        remove a process P from S->queue;
        wakeup(P)
    }
}
```



#### 세마포어 주요 함수 (POSIX 세마포어)

* sem_open() : 세마포어를 생성
* sem_wait() : 임계 영역 접근 전 세마포어를 잠그고 세마포어가 잠겨있다면 풀릴 때까지 대기
* sem_post() : 공유 자원에 대한 접근이 끝났을 때 세마포어 잠금을 해제





### 세마포어와 Mutex의 차이점

* 세마포어는 Mutex가 될 수 있지만 Mutex는 세마포어가 될 수 없다.
* 세마포어는 소유할 수 없는 반면, Mutex는 소유가 가능하면 소유주가 이에 대한 책임을 진다.
* Mutex의 경우 Mutex를 소유하고 있는 스레드가 이 Mutex를 해제할 수 있다. 하지만 세마포어의 경우 세마포어를 소유하지 않는 스레드가 세마포어를 해제할 수 있다.
* 세마포어는 시스템 범위에 걸쳐있고 파일 시스템 상의 파일 형태로 존재한다. 반면 Mutex는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 Clean Up 된다.





---

## 참고

* [Semaphore란? 세마포어와 뮤텍스의 차이는?](https://jwprogramming.tistory.com/13)