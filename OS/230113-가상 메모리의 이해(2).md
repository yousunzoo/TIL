# 가상 메모리의 이해

## 다중 단계 페이징 시스템

* 32bit 시스템에서 4KB 페이지를 위한 페이징 시스템은
  * 하위 12bit는 오프셋
  * 상위 20bit가 페이징 번호이므로, 2의 20승(1048576)개의 페이지 정보가 필요함
* 페이징 정보를 단계를 나누어 생성
  * 필요없는 페이지는 생성하지 않으면 공간 절약 가능

* 페이지 번호를 나타내는 bit를 구분해서 단계를 나눔(리눅스는 3단계, 최근 4단계)



### MMU와 TLB(컴퓨터 구조)

* MMU가 물리 주소를 확인하기 위해 메모리를 갔다와야 함
* TLB(Translation Lookaside Buffer) : 페이지 정보 캐쉬

1. CPU ➡️ MMU : Virtual address 요청
2. MMU ➡️ Memory : CR3(base address)
3. Memory ➡️ MMU : Physical address 요청
   * MMU ↔️ TLB : Physical address 전달 & 캐쉬
4. MMU ➡️ Memory : Physical address 접근
5. Memory ➡️ CPU : Data 전달



### 페이징 시스템과 공유 메모리

* 프로세스 간 동일한 물리 주소를 가리킬 수 있음 (공간 절약, 메모리 할당 시간 절약)
* 물리 주소 데이터 변경 시
  * 물리 주소에 데이터 수정 시도 시, 물리 주소를 복사할 수 있음 (copy-on-write)
  * 프로세스 생성 시간 줄임
  * 커널이던 공유 메모리던 간 공유 데이터는 물리 메모리 공간 공유 => 공간 절약





## 요구 페이징 (Demand Paging)

* 프로세스 모든 데이터를 메모리로 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재함
  * 선행 페이징(anticipatory paging 또는 prepaging)의 반대 개념 : 미리 프로세스 관련 모든 데이터를 메모리에 올려놓고 실행하는 개념
  * 더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장 (페이지 교체 알고리즘 필요)



## 페이지 폴트 (page fault)

* 어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트
* 운영체제가 page fault가 일어나면 해당 페이지를 물리 메모리에 올림



#### 생각해 보기

* 페이지 폴트가 자주 일어나면?
  * 실행되기 전에, 해당 페이지를 물리 메모리에 올려야 함
    * 시간이 오래 걸림
* 페이지 폴트가 안 일어나게 하려면?
  * 향후 실행/참조될 코드/데이터를 미리 물리 메모리에 올리면 됨
    * 앞으로 있을 일을 예측해야 함 - 신의 영역