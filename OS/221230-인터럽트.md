# 인터럽트

## 인터럽트란?

* CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치의 이벤트 또는 예외 상황이 발생하여 처리가 필요할 경우에 CPU에 알려서 처리하는 기술
  * 프로세스 중단 시, 어디까지 일을 수행했는지 저장하기 위해 CPU는 고유의 자료구조를 가진다. ➡️ 프로세스 제어 블록(PCB)

> 어느 한 순간 CPU가 실행하는 명령은 하나! 다른 장치와 어떻게 커뮤니케이션을 할까?



### 인터럽트가 필요한 이유

* 선점형 스케줄러 구현
  * 프로세스 running 중에 스케줄러가 이를 중단시키고, 다른 프로세스로 교체하기 위해 현재 프로세스 실행을 중단시킴
    * 그러기 위해선 스케줄러 코드가 실행이 되어서 현 프로세스 실행을 중지 시켜야 함
* IO Device와의 커뮤니케이션
  * 저장 매체에서 데이터 처리 완료 시, 프로세스를 깨워야 함 (block state ➡️ ready state)



![선점형 스케줄러](https://blog.kakaocdn.net/dn/772RB/btqW4iDMmeh/Iq7xS7hvmT1m0DDs4FeCiK/img.png)



* 예외 상황 핸들링
  * CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치 이벤트 또는 예외 상황(발열이 높음 등)이 발생할 경우, CPU가 해당 처리를 할 수 있도록 CPU에 알려줘야 함
    * 프로세스를 kill 해줘야 함



### 인터럽트 처리 예시

* CPU가 프로그램을 실행하고 있을 때
  * 입출력 하드웨어 등의 장치 이슈 발생
    * 파일 처리가 끝났다는 것을 운영체제에 알려주기
    * 운영체제는 해당 프로세스를 block state에서 ready 상태로 상태 변경하기
  * 또는 예외 상황이 발생
    * 0으로 나누는 계산이 발생해서 예외 상황을 운영체제에 알려주기
    * 운영체제가 해당 프로세스 실행 중지 / 에러 표시

![인터럽트 처리](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fql9lZ%2FbtqSxB7TCml%2FV0umAEOKXF14KWXT2IsgD0%2Fimg.png)





## 주요 인터럽트

1. 계산하는 코드에서 0으로 나누는 코드 실행 시 (Divide-by-Zero Interrupt)

```c
#include <stdio.h>

int main()
{
    printf("Hello Word!\n");
    int data;
    int divider = 0;
    data = 1 / divider; // 이 부분에서 인터럽트 발생
    return 0;
}
```

* 인터럽트가 발생하면 운영체제는 프로세스 실행을 중지하고 `Floating point exception (core dumped)`라는 에러 메세지를 보여준다.



2. 타이머 인터럽트
   * 선점형 스케줄러를 위해 필요
   * 하드웨어로부터 일정 시간마다 타이머 인터럽트를 운영체제에 알려줌

![타이머 인터럽트](https://www.fun-coding.org/00_Images/timer.png)



3. 입출력(I/O) 인터럽트
   * 프린터, 키보드, 마우스, 저장 매체(SSD) 등







## 인터럽트 종류

### 내부 인터럽트

* 주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용 시 발생
  * 0으로 나눴을 때
  * 사용자 모드에서 허용되지 않은 명령 또는 공간 접근 시
  * 계산 결과가 Overflow/Underflow 날 때
  * 시스템 콜에 의해 발생
* 내부 인터럽트는 주로 프로그램 내부에서 발생하므로, 소프트웨어 인터럽트라고도 함



### 외부 인터럽트

* 주로 하드웨어에서 발생되는 이벤트 (프로그램 외부)
  * 전원 이상
  * 기계 문제
  * **키보드 등 I/O 관련 이벤트**
  * **Timer 이벤트**
* 외부 인터럽트는 주로 하드웨어에서 발생하므로, 하드웨어 인터럽트라고도 함
* 보통 인터럽트라고 하면 하드웨어 인터럽트를 가리킴







## 시스템 콜 인터럽트

* 시스템 콜 실행을 위해서는 강제로 코드에 인터럽트 명령을 넣어 CPU에게 실행시켜야 한다.
* 시스템 콜 실제 코드
  1. eax 레지스터에 시스템 콜 번호를 넣고
  2. ebx 레지스터에는 시스템 콜에 해당하는 인자 값을 넣고,
  3. 소프트웨어 인터럽트 명령을 호출하면서 0x80 값을 넘겨줌

```c
mov eax, 1
mov ebx, 0
int 0x80 // 소프트웨어 인터럽트 명령
```

* 시스템 콜 인터럽트 명령을 호출하면서 `0x80` 값을 넘겨줌
* CPU는 사용자 모드를 커널 모드로 바꿔줌
* IDT(Interrupt Descriptor Table)에서 `0x80`에 해당하는 주소(함수)를 찾아서 실행함
* system_call() 함수에서 eax로부터 시스템 콜 번호를 찾아서, 해당 번호에 맞는 시스템 콜 함수로 이동
* 해당 시스템 콜 함수 실행 후, 다시 커널 모드에서 사용자 모드로 변경하고, 다시 해당 프로세스 다음 코드 진행



![시스템 콜 수행 과정](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbNCcpO%2FbtqR9nc2yj3%2FxQykuX5OCs5PdSbKsvO9G0%2Fimg.png)





## 인터럽트와 IDT

* 인터럽트는 미리 정의되어 각각 번호와 실행 코드를 가리키는 주소가 기록되어 있음
  * 어디에? ➡️ IDT(Interrupt Descriptor Table)
  * 언제? ➡️ 컴퓨터 부팅 시 운영체제가 기록
  * 어떤 코드? ➡️ 운영체제 내부 코드



* 예시 1
  * 항상 인터럽트 발생 시, IDT를 확인
  * 시스템 콜 인터럽트 명령은 0x80 번호가 미리 정의
  * 인터럽트 0x80에 해당하는 운영체제 코드는 system_call() 이라는 함수
  * 즉, IDT에는 0x80 -> system_call()과 같은 정보가 기록되어 있음
* 예시 2 - 리눅스
  * 0 ~ 31 : 예외상황 인터럽트 (일부는 정의 안된 채로 남겨져 있음)
  * 32 ~ 47 : 하드웨어 인터럽트 (주변창지 종류/갯수에 따라 변경 가능)
  * 128 : 시스템 콜





## 인터럽트와 프로세스

1. 프로세스 실행 중 인터럽트 발생
2. 현 프로세스 실행 중단, IDT로 이동
3. 인터럽트 처리 함수 실행 (운영체제)
4. 현 프로세스 재실행







---

## 참고

* [인터럽트(Interrupt) 원리](https://mikiplace.tistory.com/11)
* [시스템 콜과 인터럽트](https://latter2005.tistory.com/43)

