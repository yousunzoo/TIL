# 함수형 프로그래밍과 부수효과

## 함수형 프로그래밍

- 함수를 합성해서 복잡한 프로그램을 쉽게 만들기
- 부수 효과를 공통적인 방법으로 추상화



### 명령형 vs 함수형

| 명령형                 | 함수형(선언형)             |
| ---------------------- | -------------------------- |
| 어떻게 하는가?         | 무엇인가?                  |
| 기계에게 효율적인 방식 | 인간이 이해하기 쉬운 방식  |
| 상태 변경, 부수 효과   | 부수 효과가 없는 순수 함수 |
| 복잡한 흐름            | 작고 예측하기 쉽다         |



### 객체 지향과 함수형의 차이

* 객체 지향
  * 프로그래밍하려는 대상을 하나의 객체로 정의하는 설계 방법
  * 객체의 관점에서 구조를 만들고 사용
  * 명사의 왕국
  * 움직이는 부분을 캡슐화하여 코드 이해를 도움
  * 10개의 함수를 10개의 자료구조를 적용
* 함수형
  * 프로그래밍하려는 문제를 함수들의 정의와 조합을 통해 해결하는 방법
  * 언제든 결과가 동일한 함수 사용 가능
  * 동사의 왕국
  * 움직이는 부분을 최소화하여 코드 이해를 도움
  * 100개의 함수를 하나의 자료구조에 적용
* OOP와 함수적 계산은 조화될 수 있다.



## 부수 효과(Side Effect)

* 부수 효과 : 반환 값으로는 알 수 없는 외부의 상태를 변경하거나 예상치 못한 작용을 하는 것

  * 변수나 상태를 바꾸거나 수정
  * 화면이나 파일에 데이터를 쓰는 IO 작업
  * 다른 부수 효과가 있는 함수나 상태 값에 의존

  ➡️ 기계와 저수준에 최적화된 명령형 방식

* 명령형 프로그래밍은 부수 효과를 사용하여 프로그램이 동작하게 한다.

* 함수형 프로그래밍은 부수 효과를 최소화한다.

* 부수 효과는 합성을 어렵게 만든다.

  * 변화하는 상태를 모두 기억해야 한다.
  * 코드 실행 순서, 횟수, 분기에 따라 결과가 달라진다.
  * 비동기나 병렬 처리, 전역 상태까지 더해진다면 코드를 이해하고 결과를 예측하기는 불가능에 가깝다.

* 함수형 프로그래밍은 IO 작업이나 전역 상태를 코드에서 분리해서 기존에 부수 효과로만 다루었던 작업을 순수 함수처럼 다룰 수 있도록 추상화한다.
  * 명령형과 함수형은 상호 변환 가능 관계이다.
  * 명령형 프로그래밍으로 작성 가능한 프로그램은 모두 함수형 프로그래밍으로 변환 가능하다.



## 순수 함수

* 순수 함수 : 똑같은 매개변수(입력)를 받으면 항상 같은 값을 반환하는 함수 (`y=f(x)`)
  * 부수효과 없음
  * 수학의 함수 -> 증명 가능, 안전
  * 순서나 실행 횟수랑 상관 없이, 항상 예측 가능한 결과
  * 비교적 인간의 뇌로 생각하기 쉽고 합성하기도 쉽다.
* **부수 효과가 포함된 함수는 분해하거나 합성하는 것이 까다롭다.**
  * 함수를 호출하는 순서나 방법에 따라서도 동작이 달라질 수 있기 때문에 단순한 값으로 치환이 불가능하다.



### 함수형 프로그래밍에서 부수 효과 다루기

#### 합성하기 어려운 부수 효과 : for 문

```javascript
function sum_1_to_100(){
    let sum = 0;
    for(let i=1; i<=100; i++){
        sum+=i;
    }
    return sum;
}

console.log(sum_1_to_100())
```

* for나 while 같은 구문은 상태를 변경하고 불변성을 위반하기 때문에 함수형 프로그래밍에서는 원칙적으로 사용 불가하다.
* 순수 함수에서는 반복문을 사용할 수 없기 때문에 재귀 함수를 주로 사용한다.



#### 순수하지만 장황한 재귀

```javascript
function sum_1_to_100(){
    function go(sum, i){
        if(i>100){
            return sum;
        }
        return go(sum+i,i+1);
    }
    return go(0,1);
}

console.log(sum_1_to_100())
```

* 반복문을 함수형으로 바꿈.
* 순수한 함수이긴 하지만 여전히 복잡하다.



#### 일반화된 방식으로 추상화

```javascript
function loop(fn, acc, list){
    if(list.length === 0) return acc;
    
    const [head, ...tail] = list;
    return loop(fn, fn(acc,head), tail);
}

const range = (start, end) => Array.from(
	{length:end - start + 1},
    (_, index) => index + start
);

const plus = (a,b) => a + b;

console.log(loop(plus, 0, range(1,100))) // 5050
```

* 반복 가능한 자료구조
* 추상화된 함수 활용
  * Category 이론의 수학적 증명에 기반
* 순수하고 선언적 합성이 쉬움!
* loop와 range는 한 번 만들어두면 재사용 가능
* 예시) reduce, filter, map, flatMap



### 효과를 안전하게 추상화하기

* 숨겨진 부수 효과(부수 효과의 중첩) ➡️ 명확하고 순수한 Effect
* 뒤섞인 코드 ➡️ 효과와 계산이 직교하게 분리
* 보일러 플레이트 ➡️ 재사용하기 쉬운 추상화
* 제각각인 사용법 ➡️ 단순하고 일관된 인터페이스